#[macro_use]
extern crate clap;
#[macro_use]
extern crate lazy_static;
extern crate regex;
extern crate rustc_demangle;

use regex::{Captures, Regex};
use rustc_demangle::demangle;

use std::borrow::Cow;
use std::io::{self, Write as IoWrite};
use std::fmt::{Write as FmtWrite};
use std::process::exit;

lazy_static! {
    // NOTE: Use [[:alnum::]] instead of \w to only match ASCII word characters, not unicode
    static ref MANGLED_NAME_PATTERN: Regex = Regex::new(r"_ZN[\$\._[:alnum:]]*").unwrap();
}

fn demangle_line(line: &str, include_hash: bool) -> Cow<str> {
    MANGLED_NAME_PATTERN.replace_all(line, |captures: &Captures| {
        let original = &captures[0];
        // Allocate the buffer based on the assumption the output won't be longer than the input
        let mut buf = String::with_capacity(original.len());
        let demangled = demangle(original);
        if include_hash {
            write!(buf, "{}", demangled).unwrap();
        } else {
             // Use alternate formatting to exclude the hash from the result
            write!(buf, "{:#}", demangled).unwrap();
        }
        debug_assert!(buf.len() <= original.len(), "Output '{}' was longer than input '{}'", buf, original);
        buf
    })
}

fn demangle_stream<R: io::BufRead, W: io::Write>(input: &mut R, output: &mut W, include_hash: bool) -> io::Result<()> {
    let mut buf = String::new();
    loop {
        // NOTE: this is actually more efficient than lines(), since it re-uses the buffer
        let num_bytes = input.read_line(&mut buf)?;
        if num_bytes > 0 {
            // NOTE: This includes the line-ending, and leaves it untouched
            let demangled_line = demangle_line(&buf, include_hash).into_owned();
            if cfg!(debug_assertions) {
                debug_assert!(buf.ends_with('\n'), "No line ending in input!");
                let line_ending = if buf.ends_with("\r\n") { "\r\n" } else { "\n" };
                debug_assert!(demangled_line.ends_with(line_ending), "Demangled line has incorrect line ending");
            }
            output.write(&demangled_line.into_bytes())?;

        } else {
            return Ok(()); // Successfully hit EOF
        }
        buf.clear(); // Reset the buffer's position, without freeing it's underlying memory
    }
}

fn main() {
    let args = clap_app!(rust_demangle =>
        (version: crate_version!())
        (author: crate_authors!())
        (about: "Demangles names generated by the rust compiler")
        (@arg INCLUDE_HASH: --include-hash --hash "Include the hashes in the demangled names")
    ).get_matches();
    // NOTE: We can't combine these two, or else rust gets confused about lifetimes -_-
    let stdin = io::stdin();
    let stdout = io::stdout();
    let mut input = stdin.lock();
    let mut output = stdout.lock();
    {
        if let Err(e) = demangle_stream(&mut input, &mut output, args.is_present("INCLUDE_HASH")) {
            write!(io::stderr(), "IOError: {}", e).unwrap();
            exit(1);
        }
    }
}

#[cfg(test)]
/// Tests demangle_line, based upon the assumption demangling works properly
mod tests {
    use rustc_demangle::demangle;
    use super::demangle_line;
    static MANGLED_NAMES: &'static [&'static str] = &[
        "_ZN55_$LT$$RF$$u27$a$u20$T$u20$as$u20$core..fmt..Display$GT$3fmt17h510ed05e72307174E",
        "_ZN7example4main17h0db00b8b32acffd5E",
        "_ZN3std2io5stdio6_print17he48522be5b0a80d9E",
        "_ZN3foo17h05af221e174051e9E",
        "_ZN3foo20h05af221e174051e9abcE",
        "_ZN3foo5h05afE",
        "_ZN109_$LT$core..str..pattern..CharSearcher$LT$$u27$a$GT$$u20$as$u20$core..str..pattern..Searcher$LT$$u27$a$GT$$GT$10next_match17h9c8d80a58da7cd74E",
        "_ZN84_$LT$core..iter..Map$LT$I$C$$u20$F$GT$$u20$as$u20$core..iter..iterator..Iterator$GT$4next17h98ea4751a6975428E",
        "_ZN51_$LT$serde_json..read..IteratorRead$LT$Iter$GT$$GT$15parse_str_bytes17h8199b7867f1a334fE"
    ];
    #[test]
    fn ignores_text() {
        for text in &["boom de yada\tboom de yada\n", "bananas are fun for everyone"] {
            assert_eq!(demangle_line(text, false), *text);
            assert_eq!(demangle_line(text, true), *text);
        }
    }

    #[test]
    fn standalone_demangles() {
        for name in MANGLED_NAMES {
            assert_eq!(demangle_line(name, true).as_ref(), &demangle(name).to_string());
        }
    }

    #[test]
    fn standalone_demangles_nohash() {
        for name in MANGLED_NAMES {
            assert_eq!(demangle_line(name, false).as_ref(), &format!("{:#}", demangle(name)));
        }
    }

    fn test_embedded_line_demangle<F1, F2>(line_demangler: F1, demangler: F2) where F1: Fn(&str) -> String, F2: Fn(&str) -> String {
        for name in MANGLED_NAMES {
            macro_rules! test_context {
                ($context:expr) => (assert_eq!(line_demangler(&format!($context, name)), format!($context, demangler(name))))
            }
            // x86 ASM
            test_context!("        lea     rax, [rip + {}]");
            test_context!("        call    {}@PLT");
            // perf script --no-demangle
            test_context!("                  1a680e {} (/home/user/git/steven-rust/target/debug/steven)");
            test_context!("                  20039f {} (/home/user/git/steven-rust/target/debug/steven)");
            test_context!("                  1dade8 {} (/home/user/git/steven-rust/target/debug/steven)");
            // Random unicode symbols
            test_context!("J∆ƒƒ∆Ǥ{}∆ʓ∆ɲI∆ɳ");
            // https://xkcd.com/1638/
            test_context!(r#"cat out.txt | grep -o "\\\[[(].*\\\[{}\])][^)\]]*$""#);
            test_context!(r"\\\\\\\\{}\\\\\\\\"); // Backslash to end all other text (twice)
        }
    }

    #[test]
    fn embedded_demangle() {
        test_embedded_line_demangle(|line| demangle_line(line, false).into_owned(), |name| format!("{:#}", demangle(name)));
    }

    #[test]
    fn embedded_demangle_nohash() {
        test_embedded_line_demangle(|line| demangle_line(line, true).into_owned(), |name| demangle(name).to_string());
    }
}
